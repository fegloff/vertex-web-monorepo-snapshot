import { DEFAULT_TOAST_TTL } from 'client/components/Toast/consts';
import { asyncResult } from '@vertex-protocol/web-common';
import { createToastId } from 'client/utils/createToastId';
import { isUserDeniedError } from 'client/utils/errors/isUserDeniedError';
import { getExecuteErrorMessage } from 'client/utils/errors/getExecuteErrorMessage';
import toast from 'react-hot-toast';
import { SignaturePendingNotification } from '../components/SignaturePendingNotification';
import { PlaceOrderErrorNotification } from '../components/orders/PlaceOrderErrorNotification';
import { PlaceOrderSuccessNotification } from '../components/orders/PlaceOrderSuccessNotification';
import {
  NotificationDispatchContext,
  PlaceOrderNotificationData,
} from '../types';
import { EngineServerExecuteResult } from '@vertex-protocol/engine-client/src/types/serverExecuteTypes';

export async function handlePlaceOrderNotificationDispatch(
  placeOrderNotificationData: PlaceOrderNotificationData,
  context: NotificationDispatchContext,
) {
  const toastId = createToastId('placeOrder');

  if (!context.isSingleSignature) {
    toast.custom(
      (t) => {
        return (
          <SignaturePendingNotification
            action="place_order"
            visible={t.visible}
            onDismiss={() => {
              toast.dismiss(t.id);
            }}
          />
        );
      },
      { id: toastId, duration: Infinity },
    );
  }

  const verifyOrderActionResult = async (): Promise<string | undefined> => {
    // This typecast is only true for regular orders (not trigger orders), so do appropriate sanity checks below
    // when looking for digest
    const orderActionResult =
      (await placeOrderNotificationData.executeResult) as EngineServerExecuteResult<'place_order'>;
    if (orderActionResult.status === 'failure') {
      throw new Error('Server execution result failed');
    }
    if (orderActionResult.data) {
      return orderActionResult.data.digest;
    }
  };

  const [engineDigest, orderActionError] = await asyncResult(
    verifyOrderActionResult(),
  );
  toast.dismiss(toastId);

  if (!orderActionError) {
    // Same toast ID as the fill notification, otherwise default to autogenerated ID
    const successToastId = engineDigest ? `order-${engineDigest}` : toastId;
    toast.custom(
      (t) => {
        return (
          <PlaceOrderSuccessNotification
            visible={t.visible}
            ttl={DEFAULT_TOAST_TTL}
            orderData={placeOrderNotificationData}
            onDismiss={() => {
              toast.dismiss(t.id);
            }}
          />
        );
      },
      { id: successToastId, duration: DEFAULT_TOAST_TTL },
    );
  } else if (!isUserDeniedError(orderActionError)) {
    toast.custom(
      (t) => {
        return (
          <PlaceOrderErrorNotification
            orderData={placeOrderNotificationData}
            visible={t.visible}
            error={getExecuteErrorMessage(orderActionError)}
            ttl={DEFAULT_TOAST_TTL}
            onDismiss={() => {
              toast.dismiss(t.id);
            }}
          />
        );
      },
      { id: toastId, duration: DEFAULT_TOAST_TTL },
    );
  }
}
